<!DOCTYPE html>
<!-- saved from url=(0014)about:internet -->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<meta http-equiv="x-ua-compatible" content="IE=9" >

<title>Machine Learning</title>

<style type="text/css">
body, td {
   font-family: sans-serif;
   background-color: white;
   font-size: 12px;
   margin: 8px;
}

tt, code, pre {
   font-family: 'DejaVu Sans Mono', 'Droid Sans Mono', 'Lucida Console', Consolas, Monaco, monospace;
}

h1 { 
   font-size:2.2em; 
}

h2 { 
   font-size:1.8em; 
}

h3 { 
   font-size:1.4em; 
}

h4 { 
   font-size:1.0em; 
}

h5 { 
   font-size:0.9em; 
}

h6 { 
   font-size:0.8em; 
}

a:visited {
   color: rgb(50%, 0%, 50%);
}

pre {	
   margin-top: 0;
   max-width: 95%;
   border: 1px solid #ccc;
   white-space: pre-wrap;
}

pre code {
   display: block; padding: 0.5em;
}

code.r, code.cpp {
   background-color: #F8F8F8;
}

table, td, th {
  border: none;
}

blockquote {
   color:#666666;
   margin:0;
   padding-left: 1em;
   border-left: 0.5em #EEE solid;
}

hr {
   height: 0px;
   border-bottom: none;
   border-top-width: thin;
   border-top-style: dotted;
   border-top-color: #999999;
}

@media print {
   * { 
      background: transparent !important; 
      color: black !important; 
      filter:none !important; 
      -ms-filter: none !important; 
   }

   body { 
      font-size:12pt; 
      max-width:100%; 
   }
       
   a, a:visited { 
      text-decoration: underline; 
   }

   hr { 
      visibility: hidden;
      page-break-before: always;
   }

   pre, blockquote { 
      padding-right: 1em; 
      page-break-inside: avoid; 
   }

   tr, img { 
      page-break-inside: avoid; 
   }

   img { 
      max-width: 100% !important; 
   }

   @page :left { 
      margin: 15mm 20mm 15mm 10mm; 
   }
     
   @page :right { 
      margin: 15mm 10mm 15mm 20mm; 
   }

   p, h2, h3 { 
      orphans: 3; widows: 3; 
   }

   h2, h3 { 
      page-break-after: avoid; 
   }
}

</style>

<!-- Styles for R syntax highlighter -->
<style type="text/css">
   pre .operator,
   pre .paren {
     color: rgb(104, 118, 135)
   }

   pre .literal {
     color: rgb(88, 72, 246)
   }

   pre .number {
     color: rgb(0, 0, 205);
   }

   pre .comment {
     color: rgb(76, 136, 107);
   }

   pre .keyword {
     color: rgb(0, 0, 255);
   }

   pre .identifier {
     color: rgb(0, 0, 0);
   }

   pre .string {
     color: rgb(3, 106, 7);
   }
</style>

<!-- R syntax highlighter -->
<script type="text/javascript">
var hljs=new function(){function m(p){return p.replace(/&/gm,"&amp;").replace(/</gm,"&lt;")}function f(r,q,p){return RegExp(q,"m"+(r.cI?"i":"")+(p?"g":""))}function b(r){for(var p=0;p<r.childNodes.length;p++){var q=r.childNodes[p];if(q.nodeName=="CODE"){return q}if(!(q.nodeType==3&&q.nodeValue.match(/\s+/))){break}}}function h(t,s){var p="";for(var r=0;r<t.childNodes.length;r++){if(t.childNodes[r].nodeType==3){var q=t.childNodes[r].nodeValue;if(s){q=q.replace(/\n/g,"")}p+=q}else{if(t.childNodes[r].nodeName=="BR"){p+="\n"}else{p+=h(t.childNodes[r])}}}if(/MSIE [678]/.test(navigator.userAgent)){p=p.replace(/\r/g,"\n")}return p}function a(s){var r=s.className.split(/\s+/);r=r.concat(s.parentNode.className.split(/\s+/));for(var q=0;q<r.length;q++){var p=r[q].replace(/^language-/,"");if(e[p]){return p}}}function c(q){var p=[];(function(s,t){for(var r=0;r<s.childNodes.length;r++){if(s.childNodes[r].nodeType==3){t+=s.childNodes[r].nodeValue.length}else{if(s.childNodes[r].nodeName=="BR"){t+=1}else{if(s.childNodes[r].nodeType==1){p.push({event:"start",offset:t,node:s.childNodes[r]});t=arguments.callee(s.childNodes[r],t);p.push({event:"stop",offset:t,node:s.childNodes[r]})}}}}return t})(q,0);return p}function k(y,w,x){var q=0;var z="";var s=[];function u(){if(y.length&&w.length){if(y[0].offset!=w[0].offset){return(y[0].offset<w[0].offset)?y:w}else{return w[0].event=="start"?y:w}}else{return y.length?y:w}}function t(D){var A="<"+D.nodeName.toLowerCase();for(var B=0;B<D.attributes.length;B++){var C=D.attributes[B];A+=" "+C.nodeName.toLowerCase();if(C.value!==undefined&&C.value!==false&&C.value!==null){A+='="'+m(C.value)+'"'}}return A+">"}while(y.length||w.length){var v=u().splice(0,1)[0];z+=m(x.substr(q,v.offset-q));q=v.offset;if(v.event=="start"){z+=t(v.node);s.push(v.node)}else{if(v.event=="stop"){var p,r=s.length;do{r--;p=s[r];z+=("</"+p.nodeName.toLowerCase()+">")}while(p!=v.node);s.splice(r,1);while(r<s.length){z+=t(s[r]);r++}}}}return z+m(x.substr(q))}function j(){function q(x,y,v){if(x.compiled){return}var u;var s=[];if(x.k){x.lR=f(y,x.l||hljs.IR,true);for(var w in x.k){if(!x.k.hasOwnProperty(w)){continue}if(x.k[w] instanceof Object){u=x.k[w]}else{u=x.k;w="keyword"}for(var r in u){if(!u.hasOwnProperty(r)){continue}x.k[r]=[w,u[r]];s.push(r)}}}if(!v){if(x.bWK){x.b="\\b("+s.join("|")+")\\s"}x.bR=f(y,x.b?x.b:"\\B|\\b");if(!x.e&&!x.eW){x.e="\\B|\\b"}if(x.e){x.eR=f(y,x.e)}}if(x.i){x.iR=f(y,x.i)}if(x.r===undefined){x.r=1}if(!x.c){x.c=[]}x.compiled=true;for(var t=0;t<x.c.length;t++){if(x.c[t]=="self"){x.c[t]=x}q(x.c[t],y,false)}if(x.starts){q(x.starts,y,false)}}for(var p in e){if(!e.hasOwnProperty(p)){continue}q(e[p].dM,e[p],true)}}function d(B,C){if(!j.called){j();j.called=true}function q(r,M){for(var L=0;L<M.c.length;L++){if((M.c[L].bR.exec(r)||[null])[0]==r){return M.c[L]}}}function v(L,r){if(D[L].e&&D[L].eR.test(r)){return 1}if(D[L].eW){var M=v(L-1,r);return M?M+1:0}return 0}function w(r,L){return L.i&&L.iR.test(r)}function K(N,O){var M=[];for(var L=0;L<N.c.length;L++){M.push(N.c[L].b)}var r=D.length-1;do{if(D[r].e){M.push(D[r].e)}r--}while(D[r+1].eW);if(N.i){M.push(N.i)}return f(O,M.join("|"),true)}function p(M,L){var N=D[D.length-1];if(!N.t){N.t=K(N,E)}N.t.lastIndex=L;var r=N.t.exec(M);return r?[M.substr(L,r.index-L),r[0],false]:[M.substr(L),"",true]}function z(N,r){var L=E.cI?r[0].toLowerCase():r[0];var M=N.k[L];if(M&&M instanceof Array){return M}return false}function F(L,P){L=m(L);if(!P.k){return L}var r="";var O=0;P.lR.lastIndex=0;var M=P.lR.exec(L);while(M){r+=L.substr(O,M.index-O);var N=z(P,M);if(N){x+=N[1];r+='<span class="'+N[0]+'">'+M[0]+"</span>"}else{r+=M[0]}O=P.lR.lastIndex;M=P.lR.exec(L)}return r+L.substr(O,L.length-O)}function J(L,M){if(M.sL&&e[M.sL]){var r=d(M.sL,L);x+=r.keyword_count;return r.value}else{return F(L,M)}}function I(M,r){var L=M.cN?'<span class="'+M.cN+'">':"";if(M.rB){y+=L;M.buffer=""}else{if(M.eB){y+=m(r)+L;M.buffer=""}else{y+=L;M.buffer=r}}D.push(M);A+=M.r}function G(N,M,Q){var R=D[D.length-1];if(Q){y+=J(R.buffer+N,R);return false}var P=q(M,R);if(P){y+=J(R.buffer+N,R);I(P,M);return P.rB}var L=v(D.length-1,M);if(L){var O=R.cN?"</span>":"";if(R.rE){y+=J(R.buffer+N,R)+O}else{if(R.eE){y+=J(R.buffer+N,R)+O+m(M)}else{y+=J(R.buffer+N+M,R)+O}}while(L>1){O=D[D.length-2].cN?"</span>":"";y+=O;L--;D.length--}var r=D[D.length-1];D.length--;D[D.length-1].buffer="";if(r.starts){I(r.starts,"")}return R.rE}if(w(M,R)){throw"Illegal"}}var E=e[B];var D=[E.dM];var A=0;var x=0;var y="";try{var s,u=0;E.dM.buffer="";do{s=p(C,u);var t=G(s[0],s[1],s[2]);u+=s[0].length;if(!t){u+=s[1].length}}while(!s[2]);if(D.length>1){throw"Illegal"}return{r:A,keyword_count:x,value:y}}catch(H){if(H=="Illegal"){return{r:0,keyword_count:0,value:m(C)}}else{throw H}}}function g(t){var p={keyword_count:0,r:0,value:m(t)};var r=p;for(var q in e){if(!e.hasOwnProperty(q)){continue}var s=d(q,t);s.language=q;if(s.keyword_count+s.r>r.keyword_count+r.r){r=s}if(s.keyword_count+s.r>p.keyword_count+p.r){r=p;p=s}}if(r.language){p.second_best=r}return p}function i(r,q,p){if(q){r=r.replace(/^((<[^>]+>|\t)+)/gm,function(t,w,v,u){return w.replace(/\t/g,q)})}if(p){r=r.replace(/\n/g,"<br>")}return r}function n(t,w,r){var x=h(t,r);var v=a(t);var y,s;if(v){y=d(v,x)}else{return}var q=c(t);if(q.length){s=document.createElement("pre");s.innerHTML=y.value;y.value=k(q,c(s),x)}y.value=i(y.value,w,r);var u=t.className;if(!u.match("(\\s|^)(language-)?"+v+"(\\s|$)")){u=u?(u+" "+v):v}if(/MSIE [678]/.test(navigator.userAgent)&&t.tagName=="CODE"&&t.parentNode.tagName=="PRE"){s=t.parentNode;var p=document.createElement("div");p.innerHTML="<pre><code>"+y.value+"</code></pre>";t=p.firstChild.firstChild;p.firstChild.cN=s.cN;s.parentNode.replaceChild(p.firstChild,s)}else{t.innerHTML=y.value}t.className=u;t.result={language:v,kw:y.keyword_count,re:y.r};if(y.second_best){t.second_best={language:y.second_best.language,kw:y.second_best.keyword_count,re:y.second_best.r}}}function o(){if(o.called){return}o.called=true;var r=document.getElementsByTagName("pre");for(var p=0;p<r.length;p++){var q=b(r[p]);if(q){n(q,hljs.tabReplace)}}}function l(){if(window.addEventListener){window.addEventListener("DOMContentLoaded",o,false);window.addEventListener("load",o,false)}else{if(window.attachEvent){window.attachEvent("onload",o)}else{window.onload=o}}}var e={};this.LANGUAGES=e;this.highlight=d;this.highlightAuto=g;this.fixMarkup=i;this.highlightBlock=n;this.initHighlighting=o;this.initHighlightingOnLoad=l;this.IR="[a-zA-Z][a-zA-Z0-9_]*";this.UIR="[a-zA-Z_][a-zA-Z0-9_]*";this.NR="\\b\\d+(\\.\\d+)?";this.CNR="\\b(0[xX][a-fA-F0-9]+|(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)";this.BNR="\\b(0b[01]+)";this.RSR="!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|\\.|-|-=|/|/=|:|;|<|<<|<<=|<=|=|==|===|>|>=|>>|>>=|>>>|>>>=|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~";this.ER="(?![\\s\\S])";this.BE={b:"\\\\.",r:0};this.ASM={cN:"string",b:"'",e:"'",i:"\\n",c:[this.BE],r:0};this.QSM={cN:"string",b:'"',e:'"',i:"\\n",c:[this.BE],r:0};this.CLCM={cN:"comment",b:"//",e:"$"};this.CBLCLM={cN:"comment",b:"/\\*",e:"\\*/"};this.HCM={cN:"comment",b:"#",e:"$"};this.NM={cN:"number",b:this.NR,r:0};this.CNM={cN:"number",b:this.CNR,r:0};this.BNM={cN:"number",b:this.BNR,r:0};this.inherit=function(r,s){var p={};for(var q in r){p[q]=r[q]}if(s){for(var q in s){p[q]=s[q]}}return p}}();hljs.LANGUAGES.cpp=function(){var a={keyword:{"false":1,"int":1,"float":1,"while":1,"private":1,"char":1,"catch":1,"export":1,virtual:1,operator:2,sizeof:2,dynamic_cast:2,typedef:2,const_cast:2,"const":1,struct:1,"for":1,static_cast:2,union:1,namespace:1,unsigned:1,"long":1,"throw":1,"volatile":2,"static":1,"protected":1,bool:1,template:1,mutable:1,"if":1,"public":1,friend:2,"do":1,"return":1,"goto":1,auto:1,"void":2,"enum":1,"else":1,"break":1,"new":1,extern:1,using:1,"true":1,"class":1,asm:1,"case":1,typeid:1,"short":1,reinterpret_cast:2,"default":1,"double":1,register:1,explicit:1,signed:1,typename:1,"try":1,"this":1,"switch":1,"continue":1,wchar_t:1,inline:1,"delete":1,alignof:1,char16_t:1,char32_t:1,constexpr:1,decltype:1,noexcept:1,nullptr:1,static_assert:1,thread_local:1,restrict:1,_Bool:1,complex:1},built_in:{std:1,string:1,cin:1,cout:1,cerr:1,clog:1,stringstream:1,istringstream:1,ostringstream:1,auto_ptr:1,deque:1,list:1,queue:1,stack:1,vector:1,map:1,set:1,bitset:1,multiset:1,multimap:1,unordered_set:1,unordered_map:1,unordered_multiset:1,unordered_multimap:1,array:1,shared_ptr:1}};return{dM:{k:a,i:"</",c:[hljs.CLCM,hljs.CBLCLM,hljs.QSM,{cN:"string",b:"'\\\\?.",e:"'",i:"."},{cN:"number",b:"\\b(\\d+(\\.\\d*)?|\\.\\d+)(u|U|l|L|ul|UL|f|F)"},hljs.CNM,{cN:"preprocessor",b:"#",e:"$"},{cN:"stl_container",b:"\\b(deque|list|queue|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array)\\s*<",e:">",k:a,r:10,c:["self"]}]}}}();hljs.LANGUAGES.r={dM:{c:[hljs.HCM,{cN:"number",b:"\\b0[xX][0-9a-fA-F]+[Li]?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+(?:[eE][+\\-]?\\d*)?L\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+\\.(?!\\d)(?:i\\b)?",e:hljs.IMMEDIATE_RE,r:1},{cN:"number",b:"\\b\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\.\\d+(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"keyword",b:"(?:tryCatch|library|setGeneric|setGroupGeneric)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\.",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\d+(?![\\w.])",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\b(?:function)",e:hljs.IMMEDIATE_RE,r:2},{cN:"keyword",b:"(?:if|in|break|next|repeat|else|for|return|switch|while|try|stop|warning|require|attach|detach|source|setMethod|setClass)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"literal",b:"(?:NA|NA_integer_|NA_real_|NA_character_|NA_complex_)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"literal",b:"(?:NULL|TRUE|FALSE|T|F|Inf|NaN)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"identifier",b:"[a-zA-Z.][a-zA-Z0-9._]*\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"<\\-(?!\\s*\\d)",e:hljs.IMMEDIATE_RE,r:2},{cN:"operator",b:"\\->|<\\-",e:hljs.IMMEDIATE_RE,r:1},{cN:"operator",b:"%%|~",e:hljs.IMMEDIATE_RE},{cN:"operator",b:">=|<=|==|!=|\\|\\||&&|=|\\+|\\-|\\*|/|\\^|>|<|!|&|\\||\\$|:",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"%",e:"%",i:"\\n",r:1},{cN:"identifier",b:"`",e:"`",r:0},{cN:"string",b:'"',e:'"',c:[hljs.BE],r:0},{cN:"string",b:"'",e:"'",c:[hljs.BE],r:0},{cN:"paren",b:"[[({\\])}]",e:hljs.IMMEDIATE_RE,r:0}]}};
hljs.initHighlightingOnLoad();
</script>




</head>

<body>
<h1>Machine Learning</h1>

<p>The ideia of this project is to predict 20 new observations based on the training data provided. Thisis part of the Coursera project of Machine Learning.</p>

<p>The data sets were downloaded with this code:</p>

<pre><code class="r">download.file(&quot;https://d396qusza40orc.cloudfront.net/predmachlearn/pml-training.csv&quot;, 
    &quot;pml-training.csv&quot;)
</code></pre>

<pre><code>## Error: esquema de URL n?o suportado
</code></pre>

<pre><code class="r">download.file(&quot;https://d396qusza40orc.cloudfront.net/predmachlearn/pml-testing.csv&quot;, 
    &quot;pml-testing.csv&quot;)
</code></pre>

<pre><code>## Error: esquema de URL n?o suportado
</code></pre>

<p>After that it&#39;s important to import the files and load some useful libraries</p>

<pre><code class="r">library(rattle)
</code></pre>

<pre><code>## Warning: package &#39;rattle&#39; was built under R version 2.15.3
</code></pre>

<pre><code>## Rattle: A free graphical interface for data mining with R.
## Version 3.0.2 r169 Copyright (c) 2006-2013 Togaware Pty Ltd.
## Type &#39;rattle()&#39; to shake, rattle, and roll your data.
</code></pre>

<pre><code class="r">library(rpart.plot)
</code></pre>

<pre><code>## Warning: package &#39;rpart.plot&#39; was built under R version 2.15.3
</code></pre>

<pre><code>## Loading required package: rpart
</code></pre>

<pre><code class="r">library(AppliedPredictiveModeling)
</code></pre>

<pre><code>## Warning: package &#39;AppliedPredictiveModeling&#39; was built under R version
## 2.15.3
</code></pre>

<pre><code class="r">library(pgmm)
library(caret)
</code></pre>

<pre><code>## Warning: package &#39;caret&#39; was built under R version 2.15.3
</code></pre>

<pre><code>## Loading required package: lattice
## Loading required package: ggplot2
</code></pre>

<pre><code>## Warning: package &#39;ggplot2&#39; was built under R version 2.15.3
</code></pre>

<pre><code class="r">
study = read.csv(&quot;pml-training.csv&quot;)
final.test = read.csv(&quot;pml-testing.csv&quot;)
</code></pre>

<p>I&#39;ve opted for dividing the training data into two. As my analisys can take a while, the actual training data set is only 30% of the total data.</p>

<pre><code class="r">set.seed(2525)
train.sample = sample(1:dim(study)[1], size = dim(study)[1] * 0.3, replace = F)
train = study[train.sample, ]
test = study[-train.sample, ]
</code></pre>

<p>A new data set is created, in this data set columns that had missing values were removed</p>

<pre><code class="r">x = cbind(train$roll_belt, train$pitch_belt, train$yaw_belt, train$total_accel_belt, 
    train$gyros_belt_x, train$gyros_belt_y, train$gyros_belt_z, train$accel_belt_x, 
    train$accel_belt_y, train$accel_belt_z, train$magnet_belt_x, train$magnet_belt_y, 
    train$magnet_belt_z, train$roll_arm, train$pitch_arm, train$yaw_arm, train$total_accel_arm, 
    train$gyros_arm_x, train$gyros_arm_y, train$gyros_arm_z, train$accel_arm_x, 
    train$accel_arm_y, train$accel_arm_z, train$magnet_arm_x, train$magnet_arm_y, 
    train$magnet_arm_z, train$roll_dumbbell, train$pitch_dumbbell, train$yaw_dumbbell, 
    train$total_accel_dumbbell, train$gyros_dumbbell_x, train$gyros_dumbbell_y, 
    train$gyros_dumbbell_z, train$accel_dumbbell_x, train$accel_dumbbell_y, 
    train$accel_dumbbell_z, train$magnet_dumbbell_x, train$magnet_dumbbell_y, 
    train$magnet_dumbbell_z, train$roll_forearm, train$pitch_forearm, train$yaw_forearm, 
    train$total_accel_forearm, train$gyros_forearm_x, train$gyros_forearm_y, 
    train$gyros_forearm_z, train$accel_forearm_x, train$accel_forearm_y, train$accel_forearm_z, 
    train$magnet_forearm_x, train$magnet_forearm_y, train$magnet_forearm_z)
</code></pre>

<p>We still have many columns, so in a try to reduce the number of columns without losing important information for the model a Principal Components analisys is performed:</p>

<pre><code class="r">c1 = preProcess(x, method = &quot;pca&quot;, thresh = 0.5)
c2 = preProcess(x, method = &quot;pca&quot;, thresh = 0.6)
c3 = preProcess(x, method = &quot;pca&quot;, thresh = 0.7)
c4 = preProcess(x, method = &quot;pca&quot;, thresh = 0.75)
c5 = preProcess(x, method = &quot;pca&quot;, thresh = 0.8)
c6 = preProcess(x, method = &quot;pca&quot;, thresh = 0.9)
c7 = preProcess(x, method = &quot;pca&quot;, thresh = 0.95)

# number of components by % of variance explained
rbind(c(0.5, 0.6, 0.7, 0.75, 0.8, 0.9, 0.95), c(c1$numComp, c2$numComp, c3$numComp, 
    c4$numComp, c5$numComp, c6$numComp, c7$numComp))
</code></pre>

<pre><code>##      [,1] [,2] [,3]  [,4] [,5] [,6]  [,7]
## [1,]  0.5  0.6  0.7  0.75  0.8  0.9  0.95
## [2,]  5.0  7.0  9.0 11.00 13.0 20.0 26.00
</code></pre>

<p>The new data set c6. that explains 0.9 the variance was the chosen one. The transformation is applied to the training data set as well as some adjusts.</p>

<pre><code class="r">comp = predict(c6, x)
x1 = cbind(comp, train$classe)
x2 = as.data.frame(x1)
d = dim(x1)[2]
vs = rep(&quot;V&quot;, d - 1)
ids = (1:(d - 1))
labels = cbind(paste(vs, ids, sep = &quot;&quot;))
labels = c(labels, &quot;classe&quot;)
names(x2) = labels[1:d]
x2$classe = as.factor(x2$classe)
</code></pre>

<p>It&#39;s time to run the model. Having categorical answer and made me choose the Random Forest method, as it is very good at predictions with this number of observations and is doesn&#39;t have a computational cost as big as other good technics could have.</p>

<pre><code class="r">set.seed(2525)
modFit = train(classe ~ ., data = x2, method = &quot;rf&quot;)
</code></pre>

<pre><code>## Loading required package: randomForest
</code></pre>

<pre><code>## Warning: package &#39;randomForest&#39; was built under R version 2.15.3
</code></pre>

<pre><code>## randomForest 4.6-7
## Type rfNews() to see new features/changes/bug fixes.
</code></pre>

<pre><code>## Warning: package &#39;e1071&#39; was built under R version 2.15.3
</code></pre>

<p>A Backtest is executed to it&#39;s possibel to see that the model has a good perforace</p>

<pre><code class="r">est.train = predict(modFit, newdata = x2)
t = table(x2$classe, est.train)
g.result = sum(diag(t))/sum(t)
result = diag(t)/c(sum(t[, 1]), sum(t[, 2]), sum(t[, 3]), sum(t[, 4]), sum(t[, 
    5]))
result
</code></pre>

<pre><code>## 1 2 3 4 5 
## 1 1 1 1 1
</code></pre>

<pre><code class="r">g.result
</code></pre>

<pre><code>## [1] 1
</code></pre>

<pre><code class="r">t
</code></pre>

<pre><code>##    est.train
##        1    2    3    4    5
##   1 1716    0    0    0    0
##   2    0 1149    0    0    0
##   3    0    0  971    0    0
##   4    0    0    0  975    0
##   5    0    0    0    0 1075
</code></pre>

<p>Iy&#39;s time to apply the model in a test data set to verify if this model is really good or we have any problem, like a overfit.</p>

<p>The same transformations have to be made to the test data set</p>

<pre><code class="r">y = cbind(test$roll_belt, test$pitch_belt, test$yaw_belt, test$total_accel_belt, 
    test$gyros_belt_x, test$gyros_belt_y, test$gyros_belt_z, test$accel_belt_x, 
    test$accel_belt_y, test$accel_belt_z, test$magnet_belt_x, test$magnet_belt_y, 
    test$magnet_belt_z, test$roll_arm, test$pitch_arm, test$yaw_arm, test$total_accel_arm, 
    test$gyros_arm_x, test$gyros_arm_y, test$gyros_arm_z, test$accel_arm_x, 
    test$accel_arm_y, test$accel_arm_z, test$magnet_arm_x, test$magnet_arm_y, 
    test$magnet_arm_z, test$roll_dumbbell, test$pitch_dumbbell, test$yaw_dumbbell, 
    test$total_accel_dumbbell, test$gyros_dumbbell_x, test$gyros_dumbbell_y, 
    test$gyros_dumbbell_z, test$accel_dumbbell_x, test$accel_dumbbell_y, test$accel_dumbbell_z, 
    test$magnet_dumbbell_x, test$magnet_dumbbell_y, test$magnet_dumbbell_z, 
    test$roll_forearm, test$pitch_forearm, test$yaw_forearm, test$total_accel_forearm, 
    test$gyros_forearm_x, test$gyros_forearm_y, test$gyros_forearm_z, test$accel_forearm_x, 
    test$accel_forearm_y, test$accel_forearm_z, test$magnet_forearm_x, test$magnet_forearm_y, 
    test$magnet_forearm_z)
comp = predict(c6, y)

y1 = cbind(comp, test$classe)
y2 = as.data.frame(y1)
d = dim(y1)[2]
vs = rep(&quot;V&quot;, d - 1)
ids = (1:(d - 1))
labels = cbind(paste(vs, ids, sep = &quot;&quot;))
labels = c(labels, &quot;classe&quot;)
names(y2) = labels[1:d]
y2$classe = as.factor(y2$classe)

set.seed(2525)
est.test = predict(modFit, newdata = y2)
</code></pre>

<p>we can avalute the model performace with the code below</p>

<pre><code class="r">t = table(y2$classe, est.test)
g.result = sum(diag(t))/sum(t)
result = diag(t)/c(sum(t[, 1]), sum(t[, 2]), sum(t[, 3]), sum(t[, 4]), sum(t[, 
    5]))
result
</code></pre>

<pre><code>##      1      2      3      4      5 
## 0.9640 0.9188 0.8900 0.9439 0.9823
</code></pre>

<pre><code class="r">g.result
</code></pre>

<pre><code>## [1] 0.9415
</code></pre>

<pre><code class="r">t
</code></pre>

<pre><code>##    est.test
##        1    2    3    4    5
##   1 3746   43   27   34   14
##   2   81 2466   92    1    8
##   3   33   99 2258   48   13
##   4   19   18  125 2071    8
##   5    7   58   35   40 2392
</code></pre>

<p>The result seems acceptable, so the result will be aplied to the final test data for submission</p>

<pre><code class="r">z = cbind(final.test$roll_belt, final.test$pitch_belt, final.test$yaw_belt, 
    final.test$total_accel_belt, final.test$gyros_belt_x, final.test$gyros_belt_y, 
    final.test$gyros_belt_z, final.test$accel_belt_x, final.test$accel_belt_y, 
    final.test$accel_belt_z, final.test$magnet_belt_x, final.test$magnet_belt_y, 
    final.test$magnet_belt_z, final.test$roll_arm, final.test$pitch_arm, final.test$yaw_arm, 
    final.test$total_accel_arm, final.test$gyros_arm_x, final.test$gyros_arm_y, 
    final.test$gyros_arm_z, final.test$accel_arm_x, final.test$accel_arm_y, 
    final.test$accel_arm_z, final.test$magnet_arm_x, final.test$magnet_arm_y, 
    final.test$magnet_arm_z, final.test$roll_dumbbell, final.test$pitch_dumbbell, 
    final.test$yaw_dumbbell, final.test$total_accel_dumbbell, final.test$gyros_dumbbell_x, 
    final.test$gyros_dumbbell_y, final.test$gyros_dumbbell_z, final.test$accel_dumbbell_x, 
    final.test$accel_dumbbell_y, final.test$accel_dumbbell_z, final.test$magnet_dumbbell_x, 
    final.test$magnet_dumbbell_y, final.test$magnet_dumbbell_z, final.test$roll_forearm, 
    final.test$pitch_forearm, final.test$yaw_forearm, final.test$total_accel_forearm, 
    final.test$gyros_forearm_x, final.test$gyros_forearm_y, final.test$gyros_forearm_z, 
    final.test$accel_forearm_x, final.test$accel_forearm_y, final.test$accel_forearm_z, 
    final.test$magnet_forearm_x, final.test$magnet_forearm_y, final.test$magnet_forearm_z)

comp = predict(c6, z)

z1 = comp
z2 = as.data.frame(z1)
d = dim(z1)[2]
vs = rep(&quot;V&quot;, d)
ids = (1:(d))
labels = cbind(paste(vs, ids, sep = &quot;&quot;))

names(z2) = labels[1:d]

set.seed(2525)
est.final.test = predict(modFit, newdata = z2)
est.final.test
</code></pre>

<pre><code>##  [1] 3 1 3 1 1 2 4 2 1 1 2 3 2 1 5 5 1 2 2 2
## Levels: 1 2 3 4 5
</code></pre>

<pre><code class="r">
answers = NULL
for (i in 1:length(est.final.test)) {
    if (est.final.test[i] == 1) {
        answers = c(answers, &quot;A&quot;)
    }
    if (est.final.test[i] == 2) {
        answers = c(answers, &quot;B&quot;)
    }
    if (est.final.test[i] == 3) {
        answers = c(answers, &quot;C&quot;)
    }
    if (est.final.test[i] == 4) {
        answers = c(answers, &quot;D&quot;)
    }
    if (est.final.test[i] == 5) {
        answers = c(answers, &quot;E&quot;)
    }

}
answers
</code></pre>

<pre><code>##  [1] &quot;C&quot; &quot;A&quot; &quot;C&quot; &quot;A&quot; &quot;A&quot; &quot;B&quot; &quot;D&quot; &quot;B&quot; &quot;A&quot; &quot;A&quot; &quot;B&quot; &quot;C&quot; &quot;B&quot; &quot;A&quot; &quot;E&quot; &quot;E&quot; &quot;A&quot;
## [18] &quot;B&quot; &quot;B&quot; &quot;B&quot;
</code></pre>

<p>The last thing is to create the files for submission with the function given with the problem:</p>

<pre><code class="r">pml_write_files = function(x) {
    n = length(x)
    for (i in 1:n) {
        filename = paste0(&quot;problem_id_&quot;, i, &quot;.txt&quot;)
        write.table(x[i], file = filename, quote = FALSE, row.names = FALSE, 
            col.names = FALSE)
    }
}

pml_write_files(answers)
</code></pre>

</body>

</html>

